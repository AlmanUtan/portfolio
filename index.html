<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Elia RÃ¶mpler - Portfolio</title>
    <link rel="icon" type="image/png" href="public/img/IMG_6999.PNG" />
    <link rel="stylesheet" href="style.css" />
    <link rel="stylesheet" href="https://use.typekit.net/yyn5dss.css" />
  </head>

  <body>
    <div class="navigation">
      <button class="hamburger" onclick="openMenu()">
        <div id="bar1" class="bar"></div>
        <div id="bar2" class="bar"></div>
        <div id="bar3" class="bar"></div>
      </button>

      <nav>
        <ul>
          <li><a href="">Home</a></li>
          <li><a href="">Gallery</a></li>
          <li><a href="">About</a></li>
        </ul>
      </nav>

      <div class="socials">
        <a
          href="https://www.linkedin.com/in/elia-r%C3%B6mpler-5b4b9823b/"
          target="_blank"
          >LinkedIn</a
        >
        <a href="https://www.instagram.com/elia.roempler/" target="_blank"
          >Instagram</a
        >
        <a href="http://behance.com" target="_blank">Behance</a>
      </div>

      <div class="asterisk-image">
        <img src="public/img/IMG_6999.PNG" alt="asterisk" />
      </div>
    </div>

    <div id="canvas-container"></div>
    <button id="toggle-rotation-btn">Pause Rotation</button>
    <p>
      //scroll to zoom in and out <br />
      //press space to stop and resume the rotation
    </p>

    <!-- Intro overlay with video -->
    <div id="start-overlay" aria-hidden="false">
      <video id="introVideo" autoplay muted playsinline preload="auto">
        <source src="public/vid/platz.mp4" type="video/mp4" />
      </video>
      <!-- Small mute/unmute toggle in top-right -->
      <button id="introMuteToggle" aria-label="Toggle audio" title="Toggle audio">ðŸ”‡</button>
      <!-- Fallback play button if autoplay is blocked -->
      <button id="introPlayBtn" aria-label="Play intro" hidden>Play</button>
    </div>

    <!-- GALLERY OVERLAY -->
    <section id="galleryOverlay" aria-hidden="true">
      <div id="galleryScroll" class="galleryScroll" tabindex="-1">
        <div class="galleryGrid">
          <!-- Header row -->
          <header class="galleryRow galleryHeaderRow">
            <div class="galleryTitle">PROJECTS GALLERY</div>
            <button id="closeGalleryBtn" class="galleryClose" type="button">Close</button>
          </header>

          <div id="galleryList" class="organicGrid">
            <!-- Example cards as provided -->
            <article class="projectCard" data-page="1">
              <div class="cardPreview">
                <span class="projectName">NAME PROJECT</span>
              </div>
              <div class="cardDetails">
                <div class="videoWrapper">
                  <iframe
                    src="https://www.youtube.com/embed/LffGsgGHDOY?si=Cr9-wb88iON1a0uh"
                    frameborder="0"
                    allowfullscreen>
                  </iframe>
                </div>
                <div class="projectDescription">
                  <h3>Description</h3>
                  <p>
                    Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis posuere
                    condimentum tellus eget tristique.
                  </p>
                </div>
                <div class="projectProcess">
                  <h3>Process</h3>
                  <p>
                    Lorem ipsum dolor sit amet, consectetur adipisicing elit. Repellendus
                    deleniti, autem explicabo quisquam numquam accusamus.
                  </p>
                </div>
              </div>
            </article>

            <!-- Keep your other projectCard items unchanged -->
            <article class="projectCard" data-page="2">
              <div class="cardPreview"><span class="projectName">NAME PROJECT</span></div>
              <div class="cardDetails">
                <div class="videoWrapper">
                  <iframe src="https://www.youtube.com/embed/LffGsgGHDOY?si=Cr9-wb88iON1a0uh" frameborder="0" allowfullscreen></iframe>
                </div>
                <div class="projectDescription">
                  <h3>Description</h3>
                  <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis posuere condimentum tellus eget tristique.</p>
                </div>
                <div class="projectProcess">
                  <h3>Process</h3>
                  <p>Lorem ipsum dolor sit amet, consectetur adipisicing elit. Repellendus deleniti, autem explicabo quisquam numquam accusamus.</p>
                </div>
              </div>
            </article>

            <article class="projectCard" data-page="3">
              <div class="cardPreview"><span class="projectName">NAME PROJECT</span></div>
              <div class="cardDetails">
                <div class="videoWrapper">
                  <iframe src="https://www.youtube.com/embed/LffGsgGHDOY?si=Cr9-wb88iON1a0uh" frameborder="0" allowfullscreen></iframe>
                </div>
                <div class="projectDescription">
                  <h3>Description</h3>
                  <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis posuere condimentum tellus eget tristique.</p>
                </div>
                <div class="projectProcess">
                  <h3>Process</h3>
                  <p>Lorem ipsum dolor sit amet, consectetur adipisicing elit. Repellendus deleniti, autem explicabo quisquam numquam accusamus.</p>
                </div>
              </div>
            </article>

            <!-- ... keep the remaining cards as in your file ... -->
            <article class="projectCard" data-page="4">
              <div class="cardPreview"><span class="projectName">NAME PROJECT</span></div>
              <div class="cardDetails">
                <div class="videoWrapper">
                  <iframe src="https://www.youtube.com/embed/LffGsgGHDOY?si=Cr9-wb88iON1a0uh" frameborder="0" allowfullscreen></iframe>
                </div>
                <div class="projectDescription">
                  <h3>Description</h3>
                  <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis posuere condimentum tellus eget tristique.</p>
                </div>
                <div class="projectProcess">
                  <h3>Process</h3>
                  <p>Lorem ipsum dolor sit amet, consectetur adipisicing elit. Repellendus deleniti, autem explicabo quisquam numquam accusamus.</p>
                </div>
              </div>
            </article>

            <article class="projectCard" data-page="5">
              <div class="cardPreview"><span class="projectName">NAME PROJECT</span></div>
              <div class="cardDetails">
                <div class="videoWrapper">
                  <iframe src="https://www.youtube.com/embed/LffGsgGHDOY?si=Cr9-wb88iON1a0uh" frameborder="0" allowfullscreen></iframe>
                </div>
                <div class="projectDescription">
                  <h3>Description</h3>
                  <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis posuere condimentum tellus eget tristique.</p>
                </div>
                <div class="projectProcess">
                  <h3>Process</h3>
                  <p>Lorem ipsum dolor sit amet, consectetur adipisicing elit. Repellendus deleniti, autem explicabo quisquam numquam accusamus.</p>
                </div>
              </div>
            </article>

            <article class="projectCard" data-page="6">
              <div class="cardPreview"><span class="projectName">NAME PROJECT</span></div>
              <div class="cardDetails">
                <div class="videoWrapper">
                  <iframe src="https://www.youtube.com/embed/LffGsgGHDOY?si=Cr9-wb88iON1a0uh" frameborder="0" allowfullscreen></iframe>
                </div>
                <div class="projectDescription">
                  <h3>Description</h3>
                  <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis posuere condimentum tellus eget tristique.</p>
                </div>
                <div class="projectProcess">
                  <h3>Process</h3>
                  <p>Lorem ipsum dolor sit amet, consectetur adipisicing elit. Repellendus deleniti, autem explicabo quisquam numquam accusamus.</p>
                </div>
              </div>
            </article>

            <article class="projectCard" data-page="7">
              <div class="cardPreview"><span class="projectName">NAME PROJECT</span></div>
              <div class="cardDetails">
                <div class="videoWrapper">
                  <iframe src="https://www.youtube.com/embed/LffGsgGHDOY?si=Cr9-wb88iON1a0uh" frameborder="0" allowfullscreen></iframe>
                </div>
                <div class="projectDescription">
                  <h3>Description</h3>
                  <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis posuere condimentum tellus eget tristique.</p>
                </div>
                <div class="projectProcess">
                  <h3>Process</h3>
                  <p>Lorem ipsum dolor sit amet, consectetur adipisicing elit. Repellendus deleniti, autem explicabo quisquam numquam accusamus.</p>
                </div>
              </div>
            </article>

            <article class="projectCard" data-page="8">
              <div class="cardPreview"><span class="projectName">NAME PROJECT</span></div>
              <div class="cardDetails">
                <div class="videoWrapper">
                  <iframe src="https://www.youtube.com/embed/LffGsgGHDOY?si=Cr9-wb88iON1a0uh" frameborder="0" allowfullscreen></iframe>
                </div>
                <div class="projectDescription">
                  <h3>Description</h3>
                  <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis posuere condimentum tellus eget tristique.</p>
                </div>
                <div class="projectProcess">
                  <h3>Process</h3>
                  <p>Lorem ipsum dolor sit amet, consectetur adipisicing elit. Repellendus deleniti, autem explicabo quisquam numquam accusamus.</p>
                </div>
              </div>
            </article>
          </div>
        </div>
      </div>
    </section>

    <!-- Your UI/gallery/masonry JS -->
    <script src="script.js"></script>

    <!-- 3D app -->
    <script type="module">
      import * as THREE from "https://esm.sh/three@0.160.0";
      import { OrbitControls } from "https://esm.sh/three@0.160.0/examples/jsm/controls/OrbitControls.js";

      // Easing
      const easeInOutCubic = (t) =>
        t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;

      // --- Scene Setup ---
      class SceneManager {
        constructor(container) {
          this.container = container;
          this.scene = new THREE.Scene();
          this.scene.background = null;

          this.setupRenderer();
          this.setupCamera();
          this.setupLighting();
          this.setupControls();

          this.animationCallbacks = [];

          this.raycaster = new THREE.Raycaster();
          this.mouse = new THREE.Vector2();

          this.isDragging = false;
          this.mouseDownPos = { x: 0, y: 0 };
          this.mouseUpPos = { x: 0, y: 0 };
        }

        setupRenderer() {
          this.renderer = new THREE.WebGLRenderer({
            antialias: true,
            alpha: true,
          });
          this.renderer.setSize(window.innerWidth, window.innerHeight);
          this.renderer.setPixelRatio(window.devicePixelRatio);
          this.container.appendChild(this.renderer.domElement);

          window.addEventListener("resize", () => this.onWindowResize());

          window.addEventListener("mousemove", (event) => this.onMouseMove(event));
          this.renderer.domElement.addEventListener("mousedown", (event) =>
            this.onMouseDown(event)
          );
          this.renderer.domElement.addEventListener("mouseup", (event) =>
            this.onMouseUp(event)
          );

          this.renderer.setClearAlpha(0);
        }

        setupCamera() {
          this.camera = new THREE.PerspectiveCamera(
            75,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
          );
          this.initialPosition = new THREE.Vector3(0, 0, 0.5);
          this.initialLookAt = new THREE.Vector3(0, 0, 0);
          this.camera.position.copy(this.initialPosition);
          this.camera.lookAt(this.initialLookAt);
        }

        setupLighting() {
          const ambientLight = new THREE.AmbientLight(0xffff, 0.7);
          this.scene.add(ambientLight);

          const directionalLight = new THREE.DirectionalLight(0xffff, 0.5);
          directionalLight.position.set(1, 1, 1);
          this.scene.add(directionalLight);
        }

        setupControls() {
          this.controls = new OrbitControls(this.camera, this.renderer.domElement);
          this.controls.enablePan = false;
          this.controls.enableZoom = true;
          this.controls.minDistance = 0.5;
          this.controls.maxDistance = 8.0;
          this.controls.enableDamping = true;
          this.controls.dampingFactor = 0.18;
          this.controls.rotateSpeed = 0.9;
          this.controls.autoRotate = false;
          this.controls.enableKeys = true;
          this.controls.screenSpacePanning = false;
          this.controls.minPolarAngle = 0;
          this.controls.maxPolarAngle = Math.PI;
        }

        onMouseMove(event) {
          this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
          this.mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        }

        onMouseDown(event) {
          this.isDragging = false;
          this.mouseDownPos = { x: event.clientX, y: event.clientY };
        }

        onMouseUp(event) {
          this.mouseUpPos = { x: event.clientX, y: event.clientY };
          const dx = this.mouseUpPos.x - this.mouseDownPos.x;
          const dy = this.mouseUpPos.y - this.mouseDownPos.y;
          const dragDistance = Math.sqrt(dx * dx + dy * dy);
          if (dragDistance < 5) this.handleClick(event);
        }

        handleClick() {
          this.raycaster.setFromCamera(this.mouse, this.camera);
          const intersects = this.raycaster.intersectObjects(this.scene.children, true);
          if (intersects.length > 0) {
            const intersectedObject = intersects[0].object;
            if (intersectedObject.userData && intersectedObject.userData.pageNumber) {
              openSubpage(intersectedObject.userData.pageNumber);
            }
          }
        }

        addObject(object) {
          this.scene.add(object);
        }
        addAnimationCallback(callback) {
          this.animationCallbacks.push(callback);
        }

        animate() {
          requestAnimationFrame(() => this.animate());
          this.controls.update();
          this.animationCallbacks.forEach((cb) => cb());
          this.renderer.render(this.scene, this.camera);
        }

        onWindowResize() {
          this.camera.aspect = window.innerWidth / window.innerHeight;
          this.camera.updateProjectionMatrix();
          this.renderer.setSize(window.innerWidth, window.innerHeight);
        }
      }

      // --- Asterisk ---
      class AsteriskCreator {
        static createAsterisk(size = 1.5, color = 0x0000) {
          const group = new THREE.Group();
          const armLength = size * 1.6;
          const armWidth = size * 0.35;
          const armDepth = size * 0.45;
          const material = new THREE.MeshLambertMaterial({ color });

          for (let i = 0; i < 6; i++) {
            const geometry = new THREE.BoxGeometry(armLength, armWidth, armDepth);
            const mesh = new THREE.Mesh(geometry, material);
            mesh.rotation.z = (Math.PI / 3) * i;
            group.add(mesh);
          }
          group.rotation.x = 0;
          group.rotation.y = 0;
          group.userData.rotationSpeed = 0.01;
          return group;
        }
      }

      // --- Orbiting Rectangles with Numbers ---
      class OrbitingRectanglesManager {
        constructor(radius = 2.2, baseSurfaceArea = 1.44) {
          this.group = new THREE.Group();
          this.rects = [];

          let formats = [...Array(2).fill(1.0), ...Array(3).fill(16 / 9), ...Array(3).fill(3 / 2)];
          formats = formats
            .map((value) => ({ value, sort: Math.random() }))
            .sort((a, b) => a.sort - b.sort)
            .map(({ value }) => value);

          const totalRects = formats.length;
          const minRadius = radius * 1.1;
          const maxRadius = radius * 1.22;

          for (let i = 0; i < totalRects; i++) {
            const aspectRatio = formats[i];
            const width = Math.sqrt(baseSurfaceArea * aspectRatio);
            const height = Math.sqrt(baseSurfaceArea / aspectRatio);

            // Spherical Fibonacci lattice with jitter
            const t = i / totalRects;
            const inclination = Math.acos(1 - 2 * t);
            const azimuth = Math.PI * (1 + Math.sqrt(5)) * i;
            const jitter = (Math.random() - 0.5) * 0.22;
            const r = minRadius + (maxRadius - minRadius) * t + jitter;
            const px = r * Math.sin(inclination) * Math.cos(azimuth);
            const py = r * Math.cos(inclination);
            const pz = r * Math.sin(inclination) * Math.sin(azimuth);

            const geometry = new THREE.PlaneGeometry(width, height);

            function makeNumberTexture(num) {
              const canvas = document.createElement("canvas");
              const context = canvas.getContext("2d");
              canvas.width = 256;
              canvas.height = 256;
              context.fillStyle = "#3a7bd5";
              context.fillRect(0, 0, canvas.width, canvas.height);
              context.fillStyle = "white";
              context.font = "bold 120px Arial";
              context.textAlign = "center";
              context.textBaseline = "middle";
              context.fillText(num.toString(), canvas.width / 2, canvas.height / 2);
              return new THREE.CanvasTexture(canvas);
            }

            // Base plane (for hit area)
            const material = new THREE.MeshLambertMaterial({
              color: 0x3a7bd5,
              side: THREE.DoubleSide,
            });
            const rect = new THREE.Mesh(geometry, material);
            rect.position.set(px, py, pz);
            rect.lookAt(0, 0, 0);
            rect.userData.pageNumber = i + 1;

            // Front label
            const textMaterialFront = new THREE.MeshLambertMaterial({
              map: makeNumberTexture(i + 1),
              transparent: false,
              side: THREE.FrontSide,
            });
            const textRectFront = new THREE.Mesh(geometry, textMaterialFront);
            textRectFront.position.copy(rect.position);
            textRectFront.lookAt(0, 0, 0);
            textRectFront.position
              .add(textRectFront.getWorldDirection(new THREE.Vector3()).multiplyScalar(0.01));
            textRectFront.userData.pageNumber = i + 1;

            // Back label
            const textMaterialBack = new THREE.MeshLambertMaterial({
              map: makeNumberTexture(i + 1),
              transparent: false,
              side: THREE.FrontSide,
            });
            const textRectBack = new THREE.Mesh(geometry, textMaterialBack);
            textRectBack.position.copy(rect.position);
            textRectBack.lookAt(0, 0, 0);
            textRectBack.rotateY(Math.PI);
            textRectBack.position
              .add(textRectBack.getWorldDirection(new THREE.Vector3()).multiplyScalar(0.01));
            textRectBack.userData.pageNumber = i + 1;

            // Corner squares
            const squareSize = 0.13;
            const squareGeo = new THREE.PlaneGeometry(squareSize, squareSize);
            const squareMat = new THREE.MeshBasicMaterial({
              color: 0xff2222,
              side: THREE.DoubleSide,
            });

            const corners = [
              [-width / 2, height / 2],
              [width / 2, height / 2],
              [-width / 2, -height / 2],
              [width / 2, -height / 2],
            ];
            for (const [cx, cy] of corners) {
              const sq = new THREE.Mesh(squareGeo, squareMat);
              sq.position.copy(rect.position);
              sq.quaternion.copy(rect.quaternion);
              sq.translateX(cx);
              sq.translateY(cy);
              sq.position.add(sq.getWorldDirection(new THREE.Vector3()).multiplyScalar(0.02));
              this.group.add(sq);
            }

            this.group.add(rect);
            this.group.add(textRectFront);
            this.group.add(textRectBack);
            this.rects.push(rect, textRectFront, textRectBack);
          }

          this.group.rotation.y = Math.PI / 8;
        }

        animate(opposite = false) {
          const dir = opposite ? -1 : 1;
          this.group.rotation.y += dir * 0.01;
          this.group.rotation.x += dir * 0.005;
        }
      }

      // --- Main App ---
      class App {
        constructor() {
          this.container = document.getElementById("canvas-container");
          this.sceneManager = new SceneManager(this.container);
          this.toggleBtn = document.getElementById("toggle-rotation-btn");

          // Scroll state
          this.rotationEnabled = true;
          this.scrollAccumulator = 0;
          this.maxOverlayScroll = 100; // welcome fade-out distance
          this.maxZoomScroll = 400; // camera zoom range
          this.targetScroll = 0;
          this.scrollVelocity = 0;
          this.lastFrameTime = performance.now();

          // Objects
          this.asterisk = AsteriskCreator.createAsterisk(1.5, 0x0000);
          this.sceneManager.addObject(this.asterisk);
          this.orbitingRects = new OrbitingRectanglesManager();
          this.sceneManager.addObject(this.orbitingRects.group);

          // Overlay/video refs
          this.overlay = document.getElementById("start-overlay");
          this.overlayActive = true;

          this.introVideo = document.getElementById("introVideo");
          this.introPlayBtn = document.getElementById("introPlayBtn");
          this.introMuteBtn = document.getElementById("introMuteToggle");

          // Video state
          this.introPlaying = !!this.introVideo;
          this.lastVideoTime = 0;
          this.lastOverlayHideAt = null;
          this.userApprovedAudio = false; // set to true on any user media click

          // Init video
          if (this.introVideo) {
            const v = this.introVideo;
            v.muted = true;
            v.playsInline = true;

            const tryAutoplay = () => {
              v.play().catch(() => {
                if (this.introPlayBtn) this.introPlayBtn.hidden = false;
              });
            };
            if (v.readyState >= 2) {
              tryAutoplay();
            } else {
              v.addEventListener("canplay", tryAutoplay, { once: true });
            }

            // Keep track of current time while visible
            v.addEventListener("timeupdate", () => {
              if (!this.overlayActive) return;
              this.lastVideoTime = v.currentTime || 0;
            });

            v.addEventListener("ended", () => this.onIntroVideoEnd());
          }

          if (this.introPlayBtn) {
            this.introPlayBtn.addEventListener("click", () => {
              this.introPlayBtn.hidden = true;
              const v = this.introVideo;
              if (!v) return;
              v.muted = false;
              this.userApprovedAudio = true;
              v.play().catch(() => {});
              this.updateMuteButtonIcon();
            });
          }

          if (this.introMuteBtn) {
            this.introMuteBtn.addEventListener("click", () => {
              const v = this.introVideo;
              if (!v) return;
              v.muted = !v.muted;
              if (!v.muted) this.userApprovedAudio = true;
              v.play().catch(() => {}); // ensure playback resumes if needed
              this.updateMuteButtonIcon();
            });
          }

          // Gallery refs
          this.galleryEl = document.getElementById("galleryOverlay");
          this.galleryScroller = document.getElementById("galleryScroll");
          this.closeGalleryBtn = document.getElementById("closeGalleryBtn");
          if (this.closeGalleryBtn) {
            this.closeGalleryBtn.addEventListener("click", () => this.closeGallery());
          }

          // UI and input
          this.setupUI();
          this.setupScroll();
          this.addRotateListeners();

          // Animations
          this.sceneManager.addAnimationCallback(() => this.animateAsterisk());
          this.sceneManager.addAnimationCallback(() => this.animateRects());
          this.sceneManager.addAnimationCallback(() => this.smoothScrollStep());

          // Start loop
          this.sceneManager.animate();

          // Rotate zoom-out easing
          this.isRotating = false;
          this.preRotateZoom = null;
          this.zoomOutFactor = 2.2;
          this.zoomLerp = 0;
          this.currentZoom = null;
          this.targetZoom = null;

          // Orientation
          this.shouldOrientAsterisk = false;
          this.controlsStartBufferMs = 180;
          this.rotateStartTimer = null;
          this.addRotateListeners();

          // Gallery progressive state
          this.galleryProgress = 0;
          this.galleryProgressTarget = 0;
          this.galleryPull = 0;
          this.galleryDeadSpace = 80;
          this.galleryLift = 280;

          // Auto-scroll tween after video end
          this.autoScrollTween = null;

          this.updateMuteButtonIcon();
        }

        updateMuteButtonIcon() {
          if (!this.introMuteBtn || !this.introVideo) return;
          this.introMuteBtn.textContent = this.introVideo.muted ? "ðŸ”‡" : "ðŸ”Š";
        }

        onOverlayShown() {
          // Decide resume vs restart
          const v = this.introVideo;
          if (!v) return;

          // If we just showed it (coming from below), choose playhead
          const now = Date.now();
          const tooLong = this.lastOverlayHideAt && now - this.lastOverlayHideAt > 10000;

          if (tooLong) {
            v.currentTime = 0;
          } else {
            v.currentTime = this.lastVideoTime || 0;
          }

          // Respect prior mute choice (or browser policy)
          if (this.userApprovedAudio) {
            v.muted = false;
          } else {
            v.muted = true;
          }
          this.updateMuteButtonIcon();

          // Try to play; if blocked, leave button visible
          v.play().catch(() => {
            if (this.introPlayBtn) this.introPlayBtn.hidden = false;
          });

          this.introPlaying = true;
        }

        onOverlayHidden() {
          // Track when we hid it, store last video time
          this.lastOverlayHideAt = Date.now();
          const v = this.introVideo;
          if (!v) return;
          this.lastVideoTime = v.currentTime || 0;
          v.pause();
          this.introPlaying = false;
        }

        skipIntro(cause = "scroll") {
          if (!this.overlay) return;
          if (!this.overlayActive) return;

          this.overlay.classList.add("hidden");
          this.overlayActive = false;
          this.onOverlayHidden();

          // Optionally nudge scroll a little on skip to indicate movement
          if (cause !== "ended") {
            const smallNudge = this.maxOverlayScroll * 0.25;
            this.targetScroll = Math.min(
              this.maxOverlayScroll + this.maxZoomScroll,
              this.targetScroll + smallNudge
            );
          }
        }

        onIntroVideoEnd() {
          // Fade overlay away
          if (this.overlay) {
            this.overlay.classList.add("hidden");
            this.overlayActive = false;
          }
          this.onOverlayHidden();

          // Slow auto-scroll to a wider framed view (~62% of zoom)
          this.autoScrollToFraction(0.62, 3500);
        }

        autoScrollToFraction(fraction, durationMs = 3000) {
          const clamped = Math.max(0, Math.min(1, fraction));
          const target =
            this.maxOverlayScroll + this.maxZoomScroll * clamped;

          this.autoScrollTween = {
            start: this.targetScroll,
            end: target,
            startTime: performance.now(),
            duration: durationMs,
          };
        }

        // UI: toggle rotation button
        setupUI() {
          this.toggleBtn.addEventListener("click", () => {
            this.rotationEnabled = !this.rotationEnabled;
            this.toggleBtn.textContent = this.rotationEnabled
              ? "Pause Rotation"
              : "Resume Rotation";
          });
        }

        atZoomEnd() {
          return (
            this.scrollAccumulator >=
            this.maxOverlayScroll + this.maxZoomScroll - 0.5
          );
        }

        setupScroll() {
          let lastTouchY = null;

          const nudge3D = (delta) => {
            this.targetScroll += delta;
            this.targetScroll = Math.max(
              0,
              Math.min(this.maxOverlayScroll + this.maxZoomScroll, this.targetScroll)
            );
          };

          // Wheel
          window.addEventListener(
            "wheel",
            (e) => {
              const dy = e.deltaY;

              // If intro overlay is active, allow scroll-to-skip
              if (this.overlayActive && this.introPlaying) {
                e.preventDefault();
                this.skipIntro("scroll");
                return;
              }

              // If fully open, scroll inside gallery
              if (this.galleryProgress >= 0.999) {
                e.preventDefault();
                const prev = this.galleryScroller.scrollTop;
                this.galleryScroller.scrollTop += dy;
                if (dy < 0 && this.galleryScroller.scrollTop <= 0 && prev <= 0) {
                  this.galleryPull = this.galleryDeadSpace + this.galleryLift - 1;
                  this.galleryProgressTarget = Math.max(
                    0,
                    Math.min(
                      1,
                      (this.galleryPull - this.galleryDeadSpace) / this.galleryLift
                    )
                  );
                }
                return;
              }

              // Progressive pull region
              if (this.atZoomEnd() || this.galleryPull > 0 || this.galleryProgress > 0) {
                e.preventDefault();
                this.galleryPull += dy;
                if (this.galleryPull < 0) {
                  this.galleryPull = 0;
                  if (dy < 0) {
                    nudge3D(-8);
                  }
                }
                this.galleryProgressTarget = Math.max(
                  0,
                  Math.min(
                    1,
                    (this.galleryPull - this.galleryDeadSpace) / this.galleryLift
                  )
                );
                return;
              }

              // Normal 3D scroll
              e.preventDefault();
              nudge3D(dy > 0 ? 8 : -8);
            },
            { passive: false }
          );

          // Keyboard
          window.addEventListener("keydown", (e) => {
            // Skip on keys while intro active
            if (this.overlayActive && this.introPlaying) {
              if (e.key === "ArrowDown" || e.key === "PageDown" || e.key === " ") {
                e.preventDefault();
                this.skipIntro("key");
                return;
              }
            }

            if (this.galleryProgress >= 0.999) {
              if (e.key === "PageDown" || e.key === "ArrowDown") {
                e.preventDefault();
                this.galleryScroller.scrollTop += 120;
                return;
              }
              if (e.key === "PageUp" || e.key === "ArrowUp") {
                e.preventDefault();
                const prev = this.galleryScroller.scrollTop;
                this.galleryScroller.scrollTop -= 120;
                if (this.galleryScroller.scrollTop <= 0 && prev <= 0) {
                  this.galleryPull = this.galleryDeadSpace + this.galleryLift - 1;
                  this.galleryProgressTarget =
                    (this.galleryPull - this.galleryDeadSpace) / this.galleryLift;
                }
                return;
              }
              if (e.key === "Escape") {
                e.preventDefault();
                this.closeGallery();
                return;
              }
            }

            if (this.atZoomEnd() || this.galleryPull > 0 || this.galleryProgress > 0) {
              if (e.key === "PageDown" || e.key === "ArrowDown") {
                e.preventDefault();
                this.galleryPull += 80;
                this.galleryProgressTarget = Math.max(
                  0,
                  Math.min(
                    1,
                    (this.galleryPull - this.galleryDeadSpace) / this.galleryLift
                  )
                );
                return;
              }
              if (e.key === "PageUp" || e.key === "ArrowUp") {
                e.preventDefault();
                this.galleryPull -= 80;
                if (this.galleryPull < 0) this.galleryPull = 0;
                this.galleryProgressTarget = Math.max(
                  0,
                  Math.min(
                    1,
                    (this.galleryPull - this.galleryDeadSpace) / this.galleryLift
                  )
                );
                if (this.galleryProgressTarget <= 0) {
                  this.targetScroll = Math.max(0, this.targetScroll - 8);
                }
                return;
              }
              if (e.key === "Escape") {
                e.preventDefault();
                this.closeGallery();
                return;
              }
            }

            if (e.key === "ArrowDown" || e.key === "PageDown") {
              e.preventDefault();
              nudge3D(8);
            }
            if (e.key === "ArrowUp" || e.key === "PageUp") {
              e.preventDefault();
              nudge3D(-8);
            }
          });

          // Touch
          window.addEventListener("touchstart", (e) => {
            if (e.touches.length === 1) lastTouchY = e.touches[0].clientY;
          });
          window.addEventListener(
            "touchmove",
            (e) => {
              if (e.touches.length !== 1 || lastTouchY === null) return;

              const dy = lastTouchY - e.touches[0].clientY; // positive = swipe up
              lastTouchY = e.touches[0].clientY;

              // Skip on first touch move while intro active
              if (this.overlayActive && this.introPlaying) {
                e.preventDefault();
                this.skipIntro("touch");
                return;
              }

              if (this.galleryProgress >= 0.999) {
                this.galleryScroller.scrollTop += dy;
                const atTop = this.galleryScroller.scrollTop <= 0;
                if (dy < 0 && atTop) {
                  this.galleryPull = this.galleryDeadSpace + this.galleryLift - 1;
                  this.galleryProgressTarget =
                    (this.galleryPull - this.galleryDeadSpace) / this.galleryLift;
                }
                e.preventDefault();
                return;
              }

              if (this.atZoomEnd() || this.galleryPull > 0 || this.galleryProgress > 0) {
                this.galleryPull += dy;
                if (this.galleryPull < 0) {
                  this.galleryPull = 0;
                  if (!this.atZoomEnd() && dy < 0) {
                    this.targetScroll = Math.max(0, this.targetScroll - 8);
                  }
                }
                this.galleryProgressTarget = Math.max(
                  0,
                  Math.min(
                    1,
                    (this.galleryPull - this.galleryDeadSpace) / this.galleryLift
                  )
                );
                e.preventDefault();
                return;
              }

              e.preventDefault();
              this.targetScroll += dy > 0 ? 8 : -8;
              this.targetScroll = Math.max(
                0,
                Math.min(this.maxOverlayScroll + this.maxZoomScroll, this.targetScroll)
              );
            },
            { passive: false }
          );
        }

        openGallery() {
          this.galleryPull = this.galleryDeadSpace + this.galleryLift;
          this.galleryProgressTarget = 1;
        }

        closeGallery() {
          this.galleryPull = 0;
          this.galleryProgressTarget = 0;
        }

        addRotateListeners() {
          const controls = this.sceneManager.controls;

          controls.addEventListener("start", () => {
            if (this.rotateStartTimer) clearTimeout(this.rotateStartTimer);
            this.rotateStartTimer = setTimeout(() => {
              if (!this.isRotating) {
                this.isRotating = true;
                const cam = this.sceneManager.camera;
                this.preRotateZoom = cam.position.distanceTo(controls.target);
                this.targetZoom = this.preRotateZoom * this.zoomOutFactor;
                this.zoomLerp = 0;
              }
            }, this.controlsStartBufferMs);
          });

          controls.addEventListener("end", () => {
            if (this.rotateStartTimer) {
              clearTimeout(this.rotateStartTimer);
              this.rotateStartTimer = null;
            }
            if (this.isRotating) {
              this.isRotating = false;
              this.targetZoom = this.preRotateZoom;
              this.zoomLerp = 0;
              this.shouldOrientAsterisk = true;
            }
          });
        }

        getMinCameraZ() {
          return 0.35;
        }
        getMaxCameraZ() {
          return 5.0;
        }

        smoothScrollStep() {
          const now = performance.now();
          const dt = Math.min(1, (now - this.lastFrameTime) / 16.67);
          this.lastFrameTime = now;

          // Auto scroll tween after video end
          if (this.autoScrollTween) {
            const { start, end, startTime, duration } = this.autoScrollTween;
            const t = Math.min(1, (now - startTime) / duration);
            const k = easeInOutCubic(t);
            this.targetScroll = start + (end - start) * k;
            if (t >= 1) this.autoScrollTween = null;
          }

          const diff = this.targetScroll - this.scrollAccumulator;
          this.scrollVelocity += diff * 0.16 * dt;
          this.scrollVelocity *= 0.68;
          this.scrollAccumulator += this.scrollVelocity * dt;
          this.scrollAccumulator = Math.max(
            0,
            Math.min(this.maxOverlayScroll + this.maxZoomScroll, this.scrollAccumulator)
          );

          // Overlay show/hide based on scroll position (independent of introPlaying)
          const overlayProgress = Math.min(1, this.scrollAccumulator / this.maxOverlayScroll);

          const shouldShow = overlayProgress < 1;
          if (this.overlay) {
            if (shouldShow && !this.overlayActive) {
              // Show and resume/restart as per 10s rule
              this.overlay.classList.remove("hidden");
              this.overlayActive = true;
              this.onOverlayShown();
            } else if (!shouldShow && this.overlayActive) {
              // Hide overlay
              this.overlay.classList.add("hidden");
              this.overlayActive = false;
              this.onOverlayHidden();
            }
          }

          // Zoom progress
          let zoomProgress = 0;
          if (this.scrollAccumulator > this.maxOverlayScroll) {
            const zoomScroll = this.scrollAccumulator - this.maxOverlayScroll;
            zoomProgress = zoomScroll / this.maxZoomScroll;
          }
          zoomProgress = Math.max(0, Math.min(1, zoomProgress));

          // Camera position
          const minZ = this.getMinCameraZ();
          const maxZ = this.getMaxCameraZ();
          let z = minZ + (maxZ - minZ) * zoomProgress;

          // Camera zoom while rotating
          if (this.targetZoom !== null) {
            if (this.currentZoom === null) this.currentZoom = z;
            this.currentZoom += (this.targetZoom - this.currentZoom) * 0.08 * dt;
            z = this.currentZoom;

            if (Math.abs(this.currentZoom - this.targetZoom) < 0.01) {
              this.currentZoom = this.targetZoom;
              if (!this.isRotating) {
                this.targetZoom = null;
                this.currentZoom = null;
              }
            }
          } else {
            this.currentZoom = null;
          }

          // Interpolate camera position/orientation
          if (zoomProgress < 0.05) {
            this.sceneManager.camera.position.copy(this.sceneManager.initialPosition);
            this.sceneManager.camera.lookAt(this.sceneManager.initialLookAt);
            this.sceneManager.controls.target.copy(this.sceneManager.initialLookAt);
          } else {
            const dir = this.sceneManager.camera.position
              .clone()
              .sub(this.sceneManager.controls.target)
              .normalize();
            this.sceneManager.camera.position.copy(
              dir.multiplyScalar(z).add(this.sceneManager.controls.target)
            );
          }

          // Asterisk rotation/orientation
          if (this.asterisk) {
            let orient = false;
            if (zoomProgress < 0.5) orient = true;
            if (this.shouldOrientAsterisk) orient = true;

            if (orient) {
              const asteriskWorldPos = new THREE.Vector3();
              this.asterisk.getWorldPosition(asteriskWorldPos);
              const cameraPos = this.sceneManager.camera.position.clone();
              const target = cameraPos.sub(asteriskWorldPos).normalize();

              const targetY = Math.atan2(target.x, target.z);
              const targetX = Math.asin(-target.y);

              this.asterisk.rotation.x += (targetX - this.asterisk.rotation.x) * 0.18;
              this.asterisk.rotation.y += (targetY - this.asterisk.rotation.y) * 0.18;

              if (this.shouldOrientAsterisk) {
                if (
                  Math.abs(this.asterisk.rotation.x - targetX) < 0.03 &&
                  Math.abs(this.asterisk.rotation.y - targetY) < 0.03
                ) {
                  this.asterisk.rotation.x = targetX;
                  this.asterisk.rotation.y = targetY;
                  this.shouldOrientAsterisk = false;
                }
              }
            } else {
              this.asterisk.rotation.y += 0.01;
              this.asterisk.rotation.x += 0.007;
            }
          }

          // Update gallery transform progressively
          this.updateGalleryFrame(dt);
        }

        updateGalleryFrame(dt) {
          // Lerp to target for smoothness
          this.galleryProgress += (this.galleryProgressTarget - this.galleryProgress) * 0.18;
          if (Math.abs(this.galleryProgress - this.galleryProgressTarget) < 0.001) {
            this.galleryProgress = this.galleryProgressTarget;
          }

          // Apply transform and opacity
          const y = 100 - this.galleryProgress * 100;
          this.galleryEl.style.transform = `translateX(-50%) translateY(${y}%)`;
          const op = 0.2 + this.galleryProgress * 0.8;
          this.galleryEl.style.opacity = op.toFixed(3);

          // Enable interactions only when almost fully open
          if (this.galleryProgress >= 0.98) {
            this.galleryEl.style.pointerEvents = "auto";
          } else {
            this.galleryEl.style.pointerEvents = "none";
          }
        }

        animateAsterisk() {}
        animateRects() {
          if (this.rotationEnabled && this.orbitingRects) this.orbitingRects.animate(true);
        }
      }

      const app = new App();
      window.App = app;
    </script>
  </body>
</html>