<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <title>Elia Römpler - Portfolio</title>
    <link rel="icon" type="image/png" href="public/img/IMG_6999.PNG" />

    <meta
      name="description"
      content="Portfolio of Elia Römpler – Digital artist and designer. Explore projects in gallery, and more."
    />
    <meta name="author" content="Elia Römpler" />
    <meta
      name="keywords"
      content="Elia Römpler, Elia, Römpler, portfolio, digital, digital art, design, gallery, projects, creative, 3D, interactive "
    />

    <link rel="stylesheet" href="style.css" />
    <link rel="stylesheet" href="https://use.typekit.net/yyn5dss.css" />
  </head>

  <body>
    <div class="navigation">
      <button class="hamburger" onclick="openMenu()">
        <div id="bar1" class="bar"></div>
        <div id="bar2" class="bar"></div>
        <div id="bar3" class="bar"></div>
      </button>

      <nav>
        <ul>
          <li><a href="">Home</a></li>
          <li><a href="">Gallery</a></li>
          <li><a href="">About</a></li>
        </ul>
      </nav>

      <div class="socials">
        <a
          href="https://www.linkedin.com/in/elia-r%C3%B6mpler-5b4b9823b/"
          target="_blank"
          >LinkedIn</a
        >
        <a href="https://www.instagram.com/elia.roempler/" target="_blank"
          >Instagram</a
        >
        <a href="http://behance.com" target="_blank">Behance</a>
      </div>

      <div class="asterisk-image">
        <img src="public/img/IMG_6999.PNG" alt="asterisk" />
      </div>
    </div>

    <div id="canvas-container"></div>
    <button id="toggle-rotation-btn">Pause Rotation</button>
    <!--TODO: format this p with css as a note on the bottom left of the screen-->
    <p>
      //scroll to zoom in and out <br />
      //press space to stop and resume the rotation
    </p>

    <div id="start-overlay"><h1>Welcome</h1></div>

    <!-- Subpages -->
    <div id="subpage-1" class="subpage">
      <button class="close-btn" onclick="closeSubpage()">Close</button>
      <div>Page 1</div>
    </div>
    <div id="subpage-2" class="subpage">
      <button class="close-btn" onclick="closeSubpage()">Close</button>
      <div>Page 2</div>
    </div>
    <div id="subpage-3" class="subpage">
      <button class="close-btn" onclick="closeSubpage()">Close</button>
      <div>Page 3</div>
    </div>
    <div id="subpage-4" class="subpage">
      <button class="close-btn" onclick="closeSubpage()">Close</button>
      <div>Page 4</div>
    </div>
    <div id="subpage-5" class="subpage">
      <button class="close-btn" onclick="closeSubpage()">Close</button>
      <div>Page 5</div>
    </div>
    <div id="subpage-6" class="subpage">
      <button class="close-btn" onclick="closeSubpage()">Close</button>
      <div>Page 6</div>
    </div>
    <div id="subpage-7" class="subpage">
      <button class="close-btn" onclick="closeSubpage()">Close</button>
      <div>Page 7</div>
    </div>
    <div id="subpage-8" class="subpage">
      <button class="close-btn" onclick="closeSubpage()">Close</button>
      <div>Page 8</div>
    </div>

    <!-- GALLERY OVERLAY -->
    <!-- TODO: fix galery on the screen bottom -->
    <section id="galleryOverlay" aria-hidden="true">
      <header class="galleryHeader">
        <div class="galleryTitle">Projects Gallery</div>
        <button id="closeGalleryBtn" class="galleryClose" type="button">
          Close
        </button>
      </header>
      <!-- TODO: Change pictures of the projects and add more if needed, for that adjust the grid layout-->
      <div id="galleryScroll" class="galleryScroll" tabindex="-1">
        <div class="blobGrid" id="galleryGrid">
          <article class="blobCard span-2x2y" onclick="openSubpage(1)">
            <img
              class="blobBackgroundImage"
              src="public/img/IMG_6999.PNG"
              alt="project-image"
            />
            <div class="blobMeta">Project One</div>
            <div class="blobDesc">
              <img src="public/img/arrow-icon.svg" alt="arrow-icon" />
            </div>
          </article>
          <article class="blobCard span-2x2y" onclick="openSubpage(2)">
            <img
              class="blobBackgroundImage"
              src="public/img/IMG_6999.PNG"
              alt="project-image"
            />
            <div class="blobMeta">Project Two</div>
            <div class="blobDesc">
              <img src="public/img/arrow-icon.svg" alt="arrow-icon" />
            </div>
          </article>
          <article class="blobCard span-2x2y" onclick="openSubpage(3)">
            <img
              class="blobBackgroundImage"
              src="public/img/IMG_6999.PNG"
              alt="project-image"
            />
            <div class="blobMeta">Project Three</div>
            <div class="blobDesc">
              <img src="public/img/arrow-icon.svg" alt="arrow-icon" />
            </div>
          </article>
          <article class="blobCard span-2y" onclick="openSubpage(4)">
            <img
              class="blobBackgroundImage"
              src="public/img/IMG_6999.PNG"
              alt="project-image"
            />
            <div class="blobMeta">Project Four</div>
            <div class="blobDesc">
              <img src="public/img/arrow-icon.svg" alt="arrow-icon" />
            </div>
          </article>
        </div>
      </div>
    </section>

    <script src="script.js"></script>

    <!-- Only change: imports now use esm.sh; no import maps or shims needed -->
    <script type="module">
      import * as THREE from "https://esm.sh/three@0.160.0";
      import { OrbitControls } from "https://esm.sh/three@0.160.0/examples/jsm/controls/OrbitControls.js";

      // --- Scene Setup ---
      class SceneManager {
        constructor(container) {
          this.container = container;
          this.scene = new THREE.Scene();
          this.scene.background = null; // transparent over dark page bg

          this.setupRenderer();
          this.setupCamera();
          this.setupLighting();
          this.setupControls();

          this.animationCallbacks = [];

          // Raycasting
          this.raycaster = new THREE.Raycaster();
          this.mouse = new THREE.Vector2();

          // For click/drag distinction
          this.isDragging = false;
          this.mouseDownPos = { x: 0, y: 0 };
          this.mouseUpPos = { x: 0, y: 0 };
        }

        setupRenderer() {
          this.renderer = new THREE.WebGLRenderer({
            antialias: true,
            alpha: true,
          });
          this.renderer.setSize(window.innerWidth, window.innerHeight);
          this.renderer.setPixelRatio(window.devicePixelRatio);
          this.container.appendChild(this.renderer.domElement);

          window.addEventListener("resize", () => this.onWindowResize());

          // Mouse listeners
          window.addEventListener("mousemove", (event) =>
            this.onMouseMove(event)
          );
          this.renderer.domElement.addEventListener("mousedown", (event) =>
            this.onMouseDown(event)
          );
          this.renderer.domElement.addEventListener("mouseup", (event) =>
            this.onMouseUp(event)
          );

          this.renderer.setClearAlpha(0);
        }

        setupCamera() {
          this.camera = new THREE.PerspectiveCamera(
            75,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
          );
          // Initial close-up
          this.initialPosition = new THREE.Vector3(0, 0, 0.35);
          this.initialLookAt = new THREE.Vector3(0, 0, 0);
          this.camera.position.copy(this.initialPosition);
          this.camera.lookAt(this.initialLookAt);
        }

        setupLighting() {
          const ambientLight = new THREE.AmbientLight(0xffff, 0.7);
          this.scene.add(ambientLight);

          const directionalLight = new THREE.DirectionalLight(0xffff, 0.5);
          directionalLight.position.set(1, 1, 1);
          this.scene.add(directionalLight);
        }

        setupControls() {
          this.controls = new OrbitControls(
            this.camera,
            this.renderer.domElement
          );
          this.controls.enablePan = false;
          this.controls.enableZoom = true;
          this.controls.minDistance = 0.35;
          this.controls.maxDistance = 8.0;
          this.controls.enableDamping = true;
          this.controls.dampingFactor = 0.18;
          this.controls.rotateSpeed = 0.9;
          this.controls.autoRotate = false;
          this.controls.enableKeys = true;
          this.controls.screenSpacePanning = false;
          this.controls.minPolarAngle = 0;
          this.controls.maxPolarAngle = Math.PI;
        }

        onMouseMove(event) {
          this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
          this.mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        }

        onMouseDown(event) {
          this.isDragging = false;
          this.mouseDownPos = { x: event.clientX, y: event.clientY };
        }

        onMouseUp(event) {
          this.mouseUpPos = { x: event.clientX, y: event.clientY };
          const dx = this.mouseUpPos.x - this.mouseDownPos.x;
          const dy = this.mouseUpPos.y - this.mouseDownPos.y;
          const dragDistance = Math.sqrt(dx * dx + dy * dy);
          if (dragDistance < 5) this.handleClick(event);
        }

        handleClick() {
          this.raycaster.setFromCamera(this.mouse, this.camera);
          const intersects = this.raycaster.intersectObjects(
            this.scene.children,
            true
          );
          if (intersects.length > 0) {
            const intersectedObject = intersects[0].object;
            if (
              intersectedObject.userData &&
              intersectedObject.userData.pageNumber
            ) {
              openSubpage(intersectedObject.userData.pageNumber);
            }
          }
        }

        addObject(object) {
          this.scene.add(object);
        }
        addAnimationCallback(callback) {
          this.animationCallbacks.push(callback);
        }

        animate() {
          requestAnimationFrame(() => this.animate());
          this.controls.update();
          this.animationCallbacks.forEach((cb) => cb());
          this.renderer.render(this.scene, this.camera);
        }

        onWindowResize() {
          this.camera.aspect = window.innerWidth / window.innerHeight;
          this.camera.updateProjectionMatrix();
          this.renderer.setSize(window.innerWidth, window.innerHeight);
        }
      }

      // --- Asterisk ---
      class AsteriskCreator {
        static createAsterisk(size = 1.5, color = 0x0000) {
          const group = new THREE.Group();
          const armLength = size * 1.6;
          const armWidth = size * 0.35;
          const armDepth = size * 0.3;
          const material = new THREE.MeshLambertMaterial({ color });

          for (let i = 0; i < 6; i++) {
            const geometry = new THREE.BoxGeometry(
              armLength,
              armWidth,
              armDepth
            );
            const mesh = new THREE.Mesh(geometry, material);
            mesh.rotation.z = (Math.PI / 3) * i;
            group.add(mesh);
          }
          group.rotation.x = 0;
          group.rotation.y = 0;
          group.userData.rotationSpeed = 0.01;
          return group;
        }
      }

      // --- Orbiting Rectangles with Numbers ---
      class OrbitingRectanglesManager {
        constructor(radius = 2.2, baseSurfaceArea = 1.44) {
          this.group = new THREE.Group();
          this.rects = [];

          let formats = [
            ...Array(2).fill(1.0),
            ...Array(3).fill(16 / 9),
            ...Array(3).fill(3 / 2),
          ];
          formats = formats
            .map((value) => ({ value, sort: Math.random() }))
            .sort((a, b) => a.sort - b.sort)
            .map(({ value }) => value);

          const totalRects = formats.length;
          const minRadius = radius * 1.1;
          const maxRadius = radius * 1.22;

          for (let i = 0; i < totalRects; i++) {
            const aspectRatio = formats[i];
            const width = Math.sqrt(baseSurfaceArea * aspectRatio);
            const height = Math.sqrt(baseSurfaceArea / aspectRatio);

            // Spherical Fibonacci lattice with jitter
            const t = i / totalRects;
            const inclination = Math.acos(1 - 2 * t);
            const azimuth = Math.PI * (1 + Math.sqrt(5)) * i;
            const jitter = (Math.random() - 0.5) * 0.22;
            const r = minRadius + (maxRadius - minRadius) * t + jitter;
            const px = r * Math.sin(inclination) * Math.cos(azimuth);
            const py = r * Math.cos(inclination);
            const pz = r * Math.sin(inclination) * Math.sin(azimuth);

            const geometry = new THREE.PlaneGeometry(width, height);

            function makeNumberTexture(num) {
              const canvas = document.createElement("canvas");
              const context = canvas.getContext("2d");
              canvas.width = 256;
              canvas.height = 256;
              context.fillStyle = "#3a7bd5";
              context.fillRect(0, 0, canvas.width, canvas.height);
              context.fillStyle = "white";
              context.font = "bold 120px Arial";
              context.textAlign = "center";
              context.textBaseline = "middle";
              context.fillText(
                num.toString(),
                canvas.width / 2,
                canvas.height / 2
              );
              return new THREE.CanvasTexture(canvas);
            }

            // Base plane (for hit area)
            const material = new THREE.MeshLambertMaterial({
              color: 0x3a7bd5,
              side: THREE.DoubleSide,
            });
            const rect = new THREE.Mesh(geometry, material);
            rect.position.set(px, py, pz);
            rect.lookAt(0, 0, 0);
            rect.userData.pageNumber = i + 1;

            // Front label
            const textMaterialFront = new THREE.MeshLambertMaterial({
              map: makeNumberTexture(i + 1),
              transparent: false,
              side: THREE.FrontSide,
            });
            const textRectFront = new THREE.Mesh(geometry, textMaterialFront);
            textRectFront.position.copy(rect.position);
            textRectFront.lookAt(0, 0, 0);
            textRectFront.position.add(
              textRectFront
                .getWorldDirection(new THREE.Vector3())
                .multiplyScalar(0.01)
            );
            textRectFront.userData.pageNumber = i + 1;

            // Back label
            const textMaterialBack = new THREE.MeshLambertMaterial({
              map: makeNumberTexture(i + 1),
              transparent: false,
              side: THREE.FrontSide,
            });
            const textRectBack = new THREE.Mesh(geometry, textMaterialBack);
            textRectBack.position.copy(rect.position);
            textRectBack.lookAt(0, 0, 0);
            textRectBack.rotateY(Math.PI);
            textRectBack.position.add(
              textRectBack
                .getWorldDirection(new THREE.Vector3())
                .multiplyScalar(0.01)
            );
            textRectBack.userData.pageNumber = i + 1;

            // Corner squares
            const squareSize = 0.13;
            const squareGeo = new THREE.PlaneGeometry(squareSize, squareSize);
            const squareMat = new THREE.MeshBasicMaterial({
              color: 0xff2222,
              side: THREE.DoubleSide,
            });

            const corners = [
              [-width / 2, height / 2],
              [width / 2, height / 2],
              [-width / 2, -height / 2],
              [width / 2, -height / 2],
            ];
            for (const [cx, cy] of corners) {
              const sq = new THREE.Mesh(squareGeo, squareMat);
              sq.position.copy(rect.position);
              sq.quaternion.copy(rect.quaternion);
              sq.translateX(cx);
              sq.translateY(cy);
              sq.position.add(
                sq.getWorldDirection(new THREE.Vector3()).multiplyScalar(0.02)
              );
              this.group.add(sq);
            }

            this.group.add(rect);
            this.group.add(textRectFront);
            this.group.add(textRectBack);
            this.rects.push(rect, textRectFront, textRectBack);
          }

          this.group.rotation.y = Math.PI / 8;
        }

        animate(opposite = false) {
          const dir = opposite ? -1 : 1;
          this.group.rotation.y += dir * 0.01;
          this.group.rotation.x += dir * 0.005;
        }
      }

      // --- Main App ---
      class App {
        constructor() {
          this.container = document.getElementById("canvas-container");
          this.sceneManager = new SceneManager(this.container);
          this.toggleBtn = document.getElementById("toggle-rotation-btn");

          // Scroll state
          this.rotationEnabled = true;
          this.scrollAccumulator = 0;
          this.maxOverlayScroll = 100; // welcome fade-out distance
          this.maxZoomScroll = 400; // camera zoom range
          this.targetScroll = 0;
          this.scrollVelocity = 0;
          this.lastFrameTime = performance.now();

          // Objects
          this.asterisk = AsteriskCreator.createAsterisk(1.5, 0x0000);
          this.sceneManager.addObject(this.asterisk);
          this.orbitingRects = new OrbitingRectanglesManager();
          this.sceneManager.addObject(this.orbitingRects.group);

          // Grab DOM refs BEFORE starting the loop
          this.overlay = document.getElementById("start-overlay");
          this.overlayActive = true;

          this.galleryEl = document.getElementById("galleryOverlay");
          this.galleryScroller = document.getElementById("galleryScroll");
          this.closeGalleryBtn = document.getElementById("closeGalleryBtn");
          this.closeGalleryBtn.addEventListener("click", () =>
            this.closeGallery()
          );

          // UI and input
          this.setupUI();
          this.setupScroll();
          this.addRotateListeners();

          // Animations (callbacks can be added now, loop still not started)
          this.sceneManager.addAnimationCallback(() => this.animateAsterisk());
          this.sceneManager.addAnimationCallback(() => this.animateRects());
          this.sceneManager.addAnimationCallback(() => this.smoothScrollStep());

          // Start the loop LAST, after refs exist
          this.sceneManager.animate();

          // Rotate zoom-out easing
          this.isRotating = false;
          this.preRotateZoom = null;
          this.zoomOutFactor = 2.2;
          this.zoomLerp = 0;
          this.currentZoom = null;
          this.targetZoom = null;

          // Orientation
          this.shouldOrientAsterisk = false;
          this.controlsStartBufferMs = 180;
          this.rotateStartTimer = null;
          this.addRotateListeners();

          // Gallery progressive state
          this.galleryEl = document.getElementById("galleryOverlay");
          this.galleryScroller = document.getElementById("galleryScroll");
          this.closeGalleryBtn = document.getElementById("closeGalleryBtn");

          this.galleryProgress = 0; // 0..1 rendered
          this.galleryProgressTarget = 0; // 0..1 target
          this.galleryPull = 0; // accumulated extra scroll past zoom end
          this.galleryDeadSpace = 220; // dead space before lifting
          this.galleryLift = 520; // distance to fully open after dead space

          this.closeGalleryBtn.addEventListener("click", () =>
            this.closeGallery()
          );
        }

        // to stop/start rotation of the projects
        // TODO: remove the button code to stop the rotation and just use the space bar
        setupUI() {
          this.toggleBtn.addEventListener("click", () => {
            this.rotationEnabled = !this.rotationEnabled;
            this.toggleBtn.textContent = this.rotationEnabled
              ? "Pause Rotation"
              : "Resume Rotation";
          });

          window.addEventListener("keydown", (e) => {
            if (e.code === "Space" && !e.repeat) {
              e.preventDefault();
              this.rotationEnabled = !this.rotationEnabled;
              this.toggleBtn.textContent = this.rotationEnabled
                ? "Pause Rotation"
                : "Resume Rotation";
            }
          });
        }

        atZoomEnd() {
          return (
            this.scrollAccumulator >=
            this.maxOverlayScroll + this.maxZoomScroll - 0.5
          );
        }

        setupScroll() {
          let lastTouchY = null;

          const nudge3D = (delta) => {
            this.targetScroll += delta;
            this.targetScroll = Math.max(
              0,
              Math.min(
                this.maxOverlayScroll + this.maxZoomScroll,
                this.targetScroll
              )
            );
          };

          // Wheel
          window.addEventListener(
            "wheel",
            (e) => {
              const dy = e.deltaY;

              // If fully open, scroll inside gallery
              if (this.galleryProgress >= 0.999) {
                e.preventDefault();
                const prev = this.galleryScroller.scrollTop;
                this.galleryScroller.scrollTop += dy;
                // At top and scrolling up -> start closing
                if (
                  dy < 0 &&
                  this.galleryScroller.scrollTop <= 0 &&
                  prev <= 0
                ) {
                  this.galleryPull =
                    this.galleryDeadSpace + this.galleryLift - 1;
                  this.galleryProgressTarget = Math.max(
                    0,
                    Math.min(
                      1,
                      (this.galleryPull - this.galleryDeadSpace) /
                        this.galleryLift
                    )
                  );
                }
                return;
              }

              // Progressive pull region
              if (
                this.atZoomEnd() ||
                this.galleryPull > 0 ||
                this.galleryProgress > 0
              ) {
                e.preventDefault();
                this.galleryPull += dy;
                if (this.galleryPull < 0) {
                  this.galleryPull = 0;
                  if (dy < 0) {
                    nudge3D(-8);
                  }
                }
                this.galleryProgressTarget = Math.max(
                  0,
                  Math.min(
                    1,
                    (this.galleryPull - this.galleryDeadSpace) /
                      this.galleryLift
                  )
                );
                return;
              }

              // Normal 3D scroll before hitting the end
              e.preventDefault();
              nudge3D(dy > 0 ? 8 : -8);
            },
            { passive: false }
          );

          // Keyboard
          window.addEventListener("keydown", (e) => {
            if (this.galleryProgress >= 0.999) {
              if (e.key === "PageDown" || e.key === "ArrowDown") {
                e.preventDefault();
                this.galleryScroller.scrollTop += 120;
                return;
              }
              if (e.key === "PageUp" || e.key === "ArrowUp") {
                e.preventDefault();
                const prev = this.galleryScroller.scrollTop;
                this.galleryScroller.scrollTop -= 120;
                if (this.galleryScroller.scrollTop <= 0 && prev <= 0) {
                  this.galleryPull =
                    this.galleryDeadSpace + this.galleryLift - 1;
                  this.galleryProgressTarget =
                    (this.galleryPull - this.galleryDeadSpace) /
                    this.galleryLift;
                }
                return;
              }
              if (e.key === "Escape") {
                e.preventDefault();
                this.closeGallery();
                return;
              }
            }

            if (
              this.atZoomEnd() ||
              this.galleryPull > 0 ||
              this.galleryProgress > 0
            ) {
              if (e.key === "PageDown" || e.key === "ArrowDown") {
                e.preventDefault();
                this.galleryPull += 80;
                this.galleryProgressTarget = Math.max(
                  0,
                  Math.min(
                    1,
                    (this.galleryPull - this.galleryDeadSpace) /
                      this.galleryLift
                  )
                );
                return;
              }
              if (e.key === "PageUp" || e.key === "ArrowUp") {
                e.preventDefault();
                this.galleryPull -= 80;
                if (this.galleryPull < 0) this.galleryPull = 0;
                this.galleryProgressTarget = Math.max(
                  0,
                  Math.min(
                    1,
                    (this.galleryPull - this.galleryDeadSpace) /
                      this.galleryLift
                  )
                );
                if (this.galleryProgressTarget <= 0) {
                  this.targetScroll = Math.max(0, this.targetScroll - 8);
                }
                return;
              }
              if (e.key === "Escape") {
                e.preventDefault();
                this.closeGallery();
                return;
              }
            }

            if (e.key === "ArrowDown" || e.key === "PageDown") {
              e.preventDefault();
              nudge3D(8);
            }
            if (e.key === "ArrowUp" || e.key === "PageUp") {
              e.preventDefault();
              nudge3D(-8);
            }
          });

          // Touch
          window.addEventListener("touchstart", (e) => {
            if (e.touches.length === 1) lastTouchY = e.touches[0].clientY;
          });
          window.addEventListener(
            "touchmove",
            (e) => {
              if (e.touches.length !== 1 || lastTouchY === null) return;

              const dy = lastTouchY - e.touches[0].clientY; // positive = swipe up
              lastTouchY = e.touches[0].clientY;

              if (this.galleryProgress >= 0.999) {
                this.galleryScroller.scrollTop += dy;
                const atTop = this.galleryScroller.scrollTop <= 0;
                if (dy < 0 && atTop) {
                  this.galleryPull =
                    this.galleryDeadSpace + this.galleryLift - 1;
                  this.galleryProgressTarget =
                    (this.galleryPull - this.galleryDeadSpace) /
                    this.galleryLift;
                }
                e.preventDefault();
                return;
              }

              if (
                this.atZoomEnd() ||
                this.galleryPull > 0 ||
                this.galleryProgress > 0
              ) {
                this.galleryPull += dy;
                if (this.galleryPull < 0) {
                  this.galleryPull = 0;
                  if (!this.atZoomEnd() && dy < 0) {
                    this.targetScroll = Math.max(0, this.targetScroll - 8);
                  }
                }
                this.galleryProgressTarget = Math.max(
                  0,
                  Math.min(
                    1,
                    (this.galleryPull - this.galleryDeadSpace) /
                      this.galleryLift
                  )
                );
                e.preventDefault();
                return;
              }

              e.preventDefault();
              this.targetScroll += dy > 0 ? 8 : -8;
              this.targetScroll = Math.max(
                0,
                Math.min(
                  this.maxOverlayScroll + this.maxZoomScroll,
                  this.targetScroll
                )
              );
            },
            { passive: false }
          );
        }

        openGallery() {
          // helper if needed
          this.galleryPull = this.galleryDeadSpace + this.galleryLift;
          this.galleryProgressTarget = 1;
        }

        closeGallery() {
          this.galleryPull = 0;
          this.galleryProgressTarget = 0;
        }

        addRotateListeners() {
          const controls = this.sceneManager.controls;

          controls.addEventListener("start", () => {
            if (this.rotateStartTimer) clearTimeout(this.rotateStartTimer);
            this.rotateStartTimer = setTimeout(() => {
              if (!this.isRotating) {
                this.isRotating = true;
                const cam = this.sceneManager.camera;
                this.preRotateZoom = cam.position.distanceTo(controls.target);
                this.targetZoom = this.preRotateZoom * this.zoomOutFactor;
                this.zoomLerp = 0;
              }
            }, this.controlsStartBufferMs);
          });

          controls.addEventListener("end", () => {
            if (this.rotateStartTimer) {
              clearTimeout(this.rotateStartTimer);
              this.rotateStartTimer = null;
            }
            if (this.isRotating) {
              this.isRotating = false;
              this.targetZoom = this.preRotateZoom;
              this.zoomLerp = 0;
              this.shouldOrientAsterisk = true;
            }
          });
        }

        getMinCameraZ() {
          return 0.35;
        }
        getMaxCameraZ() {
          return 5.0;
        }

        smoothScrollStep() {
          const now = performance.now();
          const dt = Math.min(1, (now - this.lastFrameTime) / 16.67);
          this.lastFrameTime = now;

          const diff = this.targetScroll - this.scrollAccumulator;
          this.scrollVelocity += diff * 0.16 * dt;
          this.scrollVelocity *= 0.68;
          this.scrollAccumulator += this.scrollVelocity * dt;
          this.scrollAccumulator = Math.max(
            0,
            Math.min(
              this.maxOverlayScroll + this.maxZoomScroll,
              this.scrollAccumulator
            )
          );

          // Overlay fade
          if (this.overlay) {
            const overlayProgress = Math.min(
              1,
              this.scrollAccumulator / this.maxOverlayScroll
            );
            if (overlayProgress >= 1 && this.overlayActive) {
              this.overlay.classList.add("hidden");
              this.overlayActive = false;
            } else if (overlayProgress < 1 && !this.overlayActive) {
              this.overlay.classList.remove("hidden");
              this.overlayActive = true;
            }
          }

          // Zoom progress
          let zoomProgress = 0;
          if (this.scrollAccumulator > this.maxOverlayScroll) {
            const zoomScroll = this.scrollAccumulator - this.maxOverlayScroll;
            zoomProgress = zoomScroll / this.maxZoomScroll;
          }
          zoomProgress = Math.max(0, Math.min(1, zoomProgress));

          // Camera position
          const minZ = this.getMinCameraZ();
          theMaxZ: {
          }
          const maxZ = this.getMaxCameraZ();
          let z = minZ + (maxZ - minZ) * zoomProgress;

          // Camera zoom-out while rotating (slow and smooth)
          if (this.targetZoom !== null) {
            if (this.currentZoom === null) this.currentZoom = z;
            this.currentZoom +=
              (this.targetZoom - this.currentZoom) * 0.08 * dt;
            z = this.currentZoom;

            if (Math.abs(this.currentZoom - this.targetZoom) < 0.01) {
              this.currentZoom = this.targetZoom;
              if (!this.isRotating) {
                this.targetZoom = null;
                this.currentZoom = null;
              }
            }
          } else {
            this.currentZoom = null;
          }

          // Interpolate camera position and orientation
          if (zoomProgress < 0.05) {
            this.sceneManager.camera.position.copy(
              this.sceneManager.initialPosition
            );
            this.sceneManager.camera.lookAt(this.sceneManager.initialLookAt);
            this.sceneManager.controls.target.copy(
              this.sceneManager.initialLookAt
            );
          } else {
            const dir = this.sceneManager.camera.position
              .clone()
              .sub(this.sceneManager.controls.target)
              .normalize();
            this.sceneManager.camera.position.copy(
              dir.multiplyScalar(z).add(this.sceneManager.controls.target)
            );
          }

          // Asterisk rotation/orientation
          if (this.asterisk) {
            let orient = false;
            if (zoomProgress < 0.5) orient = true;
            if (this.shouldOrientAsterisk) orient = true;

            if (orient) {
              const asteriskWorldPos = new THREE.Vector3();
              this.asterisk.getWorldPosition(asteriskWorldPos);
              const cameraPos = this.sceneManager.camera.position.clone();
              const target = cameraPos.sub(asteriskWorldPos).normalize();

              const targetY = Math.atan2(target.x, target.z);
              const targetX = Math.asin(-target.y);

              this.asterisk.rotation.x +=
                (targetX - this.asterisk.rotation.x) * 0.18;
              this.asterisk.rotation.y +=
                (targetY - this.asterisk.rotation.y) * 0.18;

              if (this.shouldOrientAsterisk) {
                if (
                  Math.abs(this.asterisk.rotation.x - targetX) < 0.03 &&
                  Math.abs(this.asterisk.rotation.y - targetY) < 0.03
                ) {
                  this.asterisk.rotation.x = targetX;
                  this.asterisk.rotation.y = targetY;
                  this.shouldOrientAsterisk = false;
                }
              }
            } else {
              this.asterisk.rotation.y += 0.01;
              this.asterisk.rotation.x += 0.007;
            }
          }

          // Update gallery transform progressively
          this.updateGalleryFrame(dt);
        }

        updateGalleryFrame(dt) {
          // Lerp to target for smoothness
          this.galleryProgress +=
            (this.galleryProgressTarget - this.galleryProgress) * 0.18;
          if (
            Math.abs(this.galleryProgress - this.galleryProgressTarget) < 0.001
          ) {
            this.galleryProgress = this.galleryProgressTarget;
          }

          // Apply transform and opacity
          const y = 100 - this.galleryProgress * 100; // 100% -> 0%
          this.galleryEl.style.transform = `translateX(-50%) translateY(${y}%)`;
          const op = 0.2 + this.galleryProgress * 0.8; // fade from 0.2 -> 1
          this.galleryEl.style.opacity = op.toFixed(3);

          // Enable interactions only when almost fully open
          if (this.galleryProgress >= 0.98) {
            this.galleryEl.style.pointerEvents = "auto";
          } else {
            this.galleryEl.style.pointerEvents = "none";
          }
        }

        animateAsterisk() {}
        animateRects() {
          if (this.rotationEnabled && this.orbitingRects)
            this.orbitingRects.animate(true);
        }
      }

      new App();
    </script>
  </body>
</html>
